var documenterSearchIndex = {"docs":
[{"location":"api/#APIs","page":"APIs","title":"APIs","text":"","category":"section"},{"location":"api/#Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram{T, P}}} where {T, P}","page":"APIs","title":"Base.match","text":"match(r, zxd)\n\nReturns all matched vertices, which will be store in sturct Match, for rule r in a ZX-diagram zxd.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace!-Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram}","page":"APIs","title":"Base.replace!","text":"replace!(r, zxd)\n\nMatch and replace with the rule r.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.ne-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"Graphs.ne","text":"ne(zxd; count_mul = false)\n\nReturns the number of edges of a ZX-diagram. If count_mul, it will return the sum of multiplicities of all multiple edges. Otherwise, it will return the number of multiple edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.neighbors-Tuple{ZXCalculus.ZX.ZXDiagram, Any}","page":"APIs","title":"Graphs.neighbors","text":"neighbors(zxd, v; count_mul = false)\n\nReturns a vector of vertices connected to v. If count_mul, there will be multiple copy for each vertex. Otherwise, each vertex will only appear once.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.nv-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"Graphs.nv","text":"nv(zxd)\n\nReturns the number of vertices (spiders) of a ZX-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType, P}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType, P, Vector{T}}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.add_spider!","text":"add_spider!(zxd, spider_type, phase = 0, connect = [])\n\nAdd a new spider which is of the type spider_type with phase phase and connected to the vertices connect.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.ancilla_extraction-Tuple{ZXCalculus.ZX.ZXGraph}","page":"APIs","title":"ZXCalculus.ZX.ancilla_extraction","text":"ancilla_extraction(zxg::ZXGraph) -> ZXDiagram\n\nExtract a quantum circuit from a general ZXGraph even without a gflow.  It will introduce post-selection operators.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.biadjacency-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, Vector{T}, Vector{T}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.biadjacency","text":"biadjacency(zxg, F, N)\n\nReturn the biadjacency matrix of zxg from vertices in F to vertices in N.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.circuit_extraction-Union{Tuple{ZXCalculus.ZX.ZXGraph{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.circuit_extraction","text":"circuit_extraction(zxg::ZXGraph)\n\nExtract circuit from a graph-like ZX-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.clifford_simplification-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.clifford_simplification","text":"clifford_simplification(zxd)\n\nSimplify zxd with the algorithms in arXiv:1902.03178.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.column_loc-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T}} where T","page":"APIs","title":"ZXCalculus.ZX.column_loc","text":"column_loc(layout, v)\n\nReturn the column number corresponding to the spider v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.concat!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.ZXDiagram{T, P}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.concat!","text":"concat!(zxd_1::ZXDiagram{T,P}, zxd_2::ZXDiagram{T,P})::ZXDiagram{T,P} where {T,P}\n\nAppends two diagrams, where the second diagram is inverted\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.continued_fraction-Tuple{Any, Int64}","page":"APIs","title":"ZXCalculus.ZX.continued_fraction","text":"continued_fraction(ϕ, n::Int) -> Rational\n\nObtain s and r from ϕ that satisfies |s//r - ϕ| ≦ 1/2r²\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.gaussian_elimination-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Vector{ZXCalculus.ZX.GEStep}}} where T<:Integer","page":"APIs","title":"ZXCalculus.ZX.gaussian_elimination","text":"gaussian_elimination(M[, steps])\n\nReturn result and steps of Gaussian elimination of matrix M. Here we assume that the elements of M is in binary field F_2 = {0,1}.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.get_input_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.get_input_idx","text":"get_input_idx(zwd::ZXDiagram{T,P}, q::T) where {T,P}\n\nGet spider index of input qubit q. Returns -1 if non-existant\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.get_inputs-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.get_inputs","text":"get_inputs(zxd)\n\nReturns a vector of input ids.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.get_output_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.get_output_idx","text":"get_output_idx(zxd::ZXDiagram{T,P}, q::T) where {T,P}\n\nGet spider index of output qubit q. Returns -1 is non-existant\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.get_outputs-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.get_outputs","text":"get_outputs(zxd)\n\nReturns a vector of output ids.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.import_edges!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.ZXDiagram{T, P}, Dict{T, T}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.import_edges!","text":"import_edges!(d1::ZXDiagram{T,P}, d2::ZXDiagram{T,P}, v2tov1::Dict{T,T}) where {T,P}\n\nImport edges of d2 to d1, modify d1\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.import_non_in_out!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.ZXDiagram{T, P}, Dict{T, T}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.import_non_in_out!","text":"import_non_in_out!(d1::ZXDiagram{T,P}, d2::ZXDiagram{T,P}, v2tov1::Dict{T,T}) where {T,P}\n\nAdd non input and output spiders of d2 to d1, modify d1. Record the mapping of vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, T, ZXCalculus.ZX.SpiderType.SType}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, T, ZXCalculus.ZX.SpiderType.SType, P}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.insert_spider!","text":"insert_spider!(zxd, v1, v2, spider_type, phase = 0)\n\nInsert a spider of the type spider_type with phase = phase, between two vertices v1 and v2. It will insert multiple times if the edge between v1 and v2 is a multiple edge. Also it will remove the original edge between v1 and v2.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.is_interior-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.is_interior","text":"is_interior(zxg::ZXGraph, v)\n\nReturn true if v is a interior spider of zxg.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.nqubits-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.nqubits","text":"nqubits(zxd)\n\nReturns the qubit number of a ZX-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.phase-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.phase","text":"phase(zxd, v)\n\nReturns the phase of a spider. If the spider is not a Z or X spider, then return 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.phase_teleportation-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.phase_teleportation","text":"phase_teleportation(zxd)\n\nReducing T-count of zxd with the algorithms in arXiv:1903.10477.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.plot-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.plot","text":"plot(zxd::ZXDiagram{T, P}; kwargs...) where {T, P}\n\nPlots a ZXDiagram using Vega. \n\nIf called from the REPL it will open in the Browser. Please remeber to run \"using Vega, DataFrames\" before, as this uses an extension\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.push_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T, Any}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.push_gate!","text":"push_gate!(zxd, ::Val{M}, locs...[, phase]; autoconvert=true)\n\nPush an M gate to the end of qubit loc where M can be :Z, :X, :H, :SWAP, :CNOT and :CZ. If M is :Z or :X, phase will be available and it will push a rotation M gate with angle phase * π. If autoconvert is false, the input phase should be a rational numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.pushfirst_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T, P}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.pushfirst_gate!","text":"pushfirst_gate!(zxd, ::Val{M}, loc[, phase])\n\nPush an M gate to the beginning of qubit loc where M can be :Z, :X, :H, :SWAP, :CNOT and :CZ. If M is :Z or :X, phase will be available and it will push a rotation M gate with angle phase * π.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.qubit_loc-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T}} where T","page":"APIs","title":"ZXCalculus.ZX.qubit_loc","text":"qubit_loc(layout, v)\n\nReturn the qubit number corresponding to the spider v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.rem_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.rem_spider!","text":"rem_spider!(zxd, v)\n\nRemove a spider indexed by v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.rem_spiders!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Vector{T}}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.rem_spiders!","text":"rem_spiders!(zxd, vs)\n\nRemove spiders indexed by vs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.rewrite!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram{T, P}, Array{ZXCalculus.ZX.Match{T}, 1}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.rewrite!","text":"rewrite!(r, zxd, matches)\n\nRewrite a ZX-diagram zxd with rule r for all vertices in matches. matches can be a vector of Match or just an instance of Match.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.round_phases!-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.round_phases!","text":"round_phases!(zxd)\n\nRound phases between [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.scalar-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.scalar","text":"scalar(zxd)\n\nReturns the scalar of zxd.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.set_column!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any}} where T","page":"APIs","title":"ZXCalculus.ZX.set_column!","text":"set_qubit!(layout, v, q)\n\nSet the column number of the spider v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.set_loc!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any, Any}} where T","page":"APIs","title":"ZXCalculus.ZX.set_loc!","text":"set_loc!(layout, v, q, col)\n\nSet the location of the spider v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, P}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.set_phase!","text":"set_phase!(zxd, v, p)\n\nSet the phase of v in zxd to p.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.set_qubit!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any}} where T","page":"APIs","title":"ZXCalculus.ZX.set_qubit!","text":"set_qubit!(layout, v, q)\n\nSet the qubit number of the spider v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.simplify!-Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.simplify!","text":"simplify!(r, zxd)\n\nSimplify zxd with the rule r.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.spider_type","text":"spider_type(zxd, v)\n\nReturns the spider type of a spider.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.stype_to_val-Tuple{Any}","page":"APIs","title":"ZXCalculus.ZX.stype_to_val","text":"stype_to_val(st)::Union{SpiderType,nothing}\n\nConverts SpiderType into Val\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.tcount-Tuple{ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.tcount","text":"tcount(zxd)\n\nReturns the T-count of a ZX-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.update_frontier!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, Set{T}, Vector{T}, Dict{T, Int64}, Any}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.update_frontier!","text":"update_frontier!(zxg, frontier, qubit_map, cir)\n\nUpdate frontier. This is an important step in the circuit extraction algorithm. For more detail, please check the paper arXiv:1902.03178.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.verify_equality-Tuple{ZXCalculus.ZX.ZXDiagram, ZXCalculus.ZX.ZXDiagram}","page":"APIs","title":"ZXCalculus.ZX.verify_equality","text":"verify_equality(zxd_1::ZXDiagram, zxd_2::ZXDiagram)\n\nchecks the equivalence of two different ZXDiagrams\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.GEStep","page":"APIs","title":"ZXCalculus.ZX.GEStep","text":"GEStep\n\nA struct for representing steps in the Gaussian elimination.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.ZX.Match","page":"APIs","title":"ZXCalculus.ZX.Match","text":"Match{T<:Integer}\n\nA struct for saving matched vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.ZX.Rule","page":"APIs","title":"ZXCalculus.ZX.Rule","text":"Rule{L}\n\nThe struct for identifying different rules.\n\nRule for ZXDiagrams:\n\nRule{:f}(): rule f\nRule{:h}(): rule h\nRule{:i1}(): rule i1\nRule{:i2}(): rule i2\nRule{:pi}(): rule π\nRule{:c}(): rule c\n\nRule for ZXGraphs:\n\nRule{:lc}(): local complementary rule\nRule{:p1}(): pivoting rule\nRule{:pab}(): rule for removing Pauli spiders adjancent to boundary spiders\nRule{:p2}(): rule p2\nRule{:p3}(): rule p3\nRule{:id}(): rule id\nRule{:gf}(): gadget fushion rule\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.ZX.ZXDiagram","page":"APIs","title":"ZXCalculus.ZX.ZXDiagram","text":"ZXDiagram{T, P}\n\nThis is the type for representing ZX-diagrams.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.ZX.ZXDiagram-Tuple{T} where T<:Integer","page":"APIs","title":"ZXCalculus.ZX.ZXDiagram","text":"ZXDiagram(nbits)\n\nConstruct a ZXDiagram of a empty circuit with qubit number nbit\n\njulia> zxd = ZXDiagram(3)\nZX-diagram with 6 vertices and 3 multiple edges:\n(S_1{input} <-1-> S_2{output})\n(S_3{input} <-1-> S_4{output})\n(S_5{input} <-1-> S_6{output})\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.ZXDiagram-Union{Tuple{P}, Tuple{T}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}, ZXCalculus.ZX.ZXLayout{T}}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}, ZXCalculus.ZX.ZXLayout{T}, Dict{T, Tuple{T, Int64}}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.ZXDiagram","text":"ZXDiagram(mg::Multigraph{T}, st::Dict{T, SpiderType.SType}, ps::Dict{T, P},\n    layout::ZXLayout{T} = ZXLayout{T}(),\n    phase_ids::Dict{T,Tuple{T, Int}} = Dict{T,Tuple{T,Int}}()) where {T, P}\nZXDiagram(mg::Multigraph{T}, st::Vector{SpiderType.SType}, ps::Vector{P},\n    layout::ZXLayout{T} = ZXLayout{T}()) where {T, P}\n\nConstruct a ZXDiagram with all information.\n\njulia> using Graphs, Multigraphs, ZXCalculus.ZX;\n\njulia> using ZXCalculus.ZX.SpiderType: In, Out, H, Z, X;\n\njulia> mg = Multigraph(5);\n\njulia> for i = 1:4\n           add_edge!(mg, i, i+1)\n       end;\n\njulia> ZXDiagram(mg, [In, Z, H, X, Out], [0//1, 1, 0, 1//2, 0])\nZX-diagram with 5 vertices and 4 multiple edges:\n(S_1{input} <-1-> S_2{phase = 1//1⋅π})\n(S_2{phase = 1//1⋅π} <-1-> S_3{H})\n(S_3{H} <-1-> S_4{phase = 1//2⋅π})\n(S_4{phase = 1//2⋅π} <-1-> S_5{output})\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.ZXGraph","page":"APIs","title":"ZXCalculus.ZX.ZXGraph","text":"ZXGraph{T, P}\n\nThis is the type for representing the graph-like ZX-diagrams.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.ZX.ZXGraph-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.ZXGraph","text":"ZXGraph(zxd::ZXDiagram)\n\nConvert a ZX-diagram to graph-like ZX-diagram.\n\njulia> using ZXCalculus.ZX\n\njulia> zxd = ZXDiagram(2); push_gate!(zxd, Val{:CNOT}(), 2, 1);\n\njulia> zxg = ZXGraph(zxd)\nZX-graph with 6 vertices and 5 edges:\n(S_1{input} <-> S_5{phase = 0//1⋅π})\n(S_2{output} <-> S_5{phase = 0//1⋅π})\n(S_3{input} <-> S_6{phase = 0//1⋅π})\n(S_4{output} <-> S_6{phase = 0//1⋅π})\n(S_5{phase = 0//1⋅π} <-> S_6{phase = 0//1⋅π})\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.ZXLayout","page":"APIs","title":"ZXCalculus.ZX.ZXLayout","text":"ZXLayout\n\nA struct for the layout information of ZXDiagram and ZXGraph.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}","page":"APIs","title":"Base.match","text":"match(r, zxwd)\n\nReturns all matched vertices, which will be store in sturct Match, for rule r in a ZXW-diagram zxwd.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.Rule{:s1}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}","page":"APIs","title":"Base.match","text":"Rule that implements both f and s1 rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.ne-Tuple{ZXCalculus.ZXW.ZXWDiagram}","page":"APIs","title":"Graphs.ne","text":"ne(zxwd; count_mul = false)\n\nReturns the number of edges of a ZXW-diagram. If count_mul, it will return the sum of multiplicities of all multiple edges. Otherwise, it will return the number of multiple edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.neighbors-Tuple{ZXCalculus.ZXW.ZXWDiagram, Any}","page":"APIs","title":"Graphs.neighbors","text":"neighbors(zxwd, v; count_mul = false)\n\nReturns a vector of vertices connected to v. If count_mul, there will be multiple copy for each vertex. Otherwise, each vertex will only appear once.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.nv-Tuple{ZXCalculus.ZXW.ZXWDiagram}","page":"APIs","title":"Graphs.nv","text":"nv(zxwd)\n\nReturns the number of vertices (spiders) of a ZXW-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.push_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T, Any}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.push_gate!","text":"push_gate!(zxwd, ::Val{M}, locs...[, phase]; autoconvert=true)\n\nPush an M gate to the end of qubit loc where M can be :Z, :X, :H, :SWAP, :CNOT and :CZ. If M is :Z or :X, phase will be available and it will push a rotation M gate with angle phase * π. If autoconvert is false, the input phase should be a rational numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.pushfirst_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T, P}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.pushfirst_gate!","text":"pushfirst_gate!(zxwd, ::Val{M}, loc[, phase])\n\nPush an M gate to the beginning of qubit loc where M can be :Z, :X, :H, :SWAP, :CNOT and :CZ. If M is :Z or :X, phase will be available and it will push a rotation M gate with angle phase * π.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.rem_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.rem_spider!","text":"rem_spider!(zxwd, v)\n\nRemove a spider indexed by v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.rem_spiders!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vector{T}}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZX.rem_spiders!","text":"rem_spiders!(zxwd, vs)\n\nRemove spiders indexed by vs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.rewrite!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZXW.ZXWDiagram{T, P}, Array{ZXCalculus.ZX.Match{T}, 1}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZX.rewrite!","text":"rewrite!(r, zxd, matches)\n\nRewrite a ZX-diagram zxd with rule r for all vertices in matches. matches can be a vector of Match or just an instance of Match.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.add_inout!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.add_inout!","text":"Add input and outputs to diagram\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWSpiderType}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWSpiderType, Vector{T}}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZXW.add_spider!","text":"add_spider!(zxwd, spider, connect = [])\n\nAdd a new spider spider with appropriate parameter connected to the vertices connect. \n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.concat!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.concat!","text":"Concatenate two ZXWDiagrams, modify d1.\n\nRemove outputs of d1 and inputs of d2. Then add edges between to vertices that was conntecting to outputs of d1 and inputs of d2. Assuming you don't concatenate two empty circuit ZXWDiagram\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.dagger-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.dagger","text":"Convert ZXWDiagram that represents unitary U to U^†\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.expval_circ!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, String}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.expval_circ!","text":"Construct ZXW Diagram for representing the expectation value circuit\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.get_inputs-Tuple{ZXCalculus.ZXW.ZXWDiagram}","page":"APIs","title":"ZXCalculus.ZXW.get_inputs","text":"get_inputs(zxwd)\n\nReturns a vector of input ids.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.get_outputs-Tuple{ZXCalculus.ZXW.ZXWDiagram}","page":"APIs","title":"ZXCalculus.ZXW.get_outputs","text":"get_outputs(zxwd)\n\nReturns a vector of output ids.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.import_edges!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{T, T}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.import_edges!","text":"Import edges of d2 to d1, modify d1\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.import_non_in_out!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{T, T}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.import_non_in_out!","text":"Add non input and output spiders of d2 to d1, modify d1. Record the mapping of vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T, T, ZXCalculus.ZXW.ZXWSpiderType}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZXW.insert_spider!","text":"insert_spider!(zxwd, v1, v2, spider)\n\nInsert a spider spider with appropriate parameter, between two vertices v1 and v2. It will insert multiple times if the edge between v1 and v2 is a multiple edge. Also it will remove the original edge between v1 and v2.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.insert_wtrig!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vector{T}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.insert_wtrig!","text":"Insert W triangle on a vector of vertices\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.int_prep!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.int_prep!","text":"Prepare spider at loc for integration.\n\nPerform the simplified step of zeroing out phase of spider and readying it for integration\n\nIf target spider is X spider, turn it to Z by adding H to all its legs\nPull out the Phase of the spider\nzero out the phase\nchange the current spider back to its original type if necessary,\n\nwill generate one extra H spider.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.integrate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vararg{T, 4}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.integrate!","text":"Integrate two pairs of +/- parameter. Theorem 23 of https://arxiv.org/abs/2201.13250\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.nout-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.nout","text":"nout(zxwd)\n\nReturns the number of outputs of a ZXW-diagram\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.nqubits-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.nqubits","text":"nqubits(zxwd)\n\nReturns the qubit number of a ZXW-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.parameter-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZXW.parameter","text":"parameter(zxwd, v)\n\nReturns the parameter of a spider. If the spider is not a Z or X spider, then return 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.print_spider-Union{Tuple{P}, Tuple{T}, Tuple{IO, ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZXW.print_spider","text":"print_spider(io, zxwd, v)\n\nPrint a spider to io.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.round_phases!-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZXW.round_phases!","text":"round_phases!(zxwd)\n\nRound phases between [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T, ZXCalculus.Utils.Parameter}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.set_phase!","text":"set_phase!(zxwd, v, p)\n\nSet the phase of v in zxwd to p. If v is not a Z or X spider, then do nothing. If v is not in zxwd, then return false to indicate failure.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZXW.spider_type","text":"spider_type(zxwd, v)\n\nReturns the spider type of a spider if it exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.stack_zxwd!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.stack_zxwd!","text":"Stacking two ZXWDiagrams in place. Modify d1.\n\nPerforms tensor product of two ZXWDiagrams. The result is a ZXWDiagram with d1 on lower qubit indices. Assuming number of inputs and outputs of are the same for both d1 and d2.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.substitute_variables!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{Symbol, <:Number}}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.substitute_variables!","text":"Replace symbols in ZXW Diagram with specific values\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZXW.symbol_vertices-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Symbol}} where {T, P}","page":"APIs","title":"ZXCalculus.ZXW.symbol_vertices","text":"Finds vertices of Spider that contains the parameter θ or -θ\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_edge!-Tuple{ZXCalculus.ZW.ZWDiagram, Any, Int64}","page":"APIs","title":"Graphs.SimpleGraphs.add_edge!","text":"Graphs.add_edge!(zwd::ZWDiagram, he, mul)\n\nAdd mul of edges that connects vertices with already connected with edgex.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.rem_edge!-Tuple{ZXCalculus.ZW.ZWDiagram, Any}","page":"APIs","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(zwd::ZWDiagram, x)\n\nRemove Edge with indices x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.ne-Tuple{ZXCalculus.ZW.ZWDiagram}","page":"APIs","title":"Graphs.ne","text":"ne(zwd)\n\nReturns the number of edges of a ZW-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.neighbors-Tuple{ZXCalculus.ZW.ZWDiagram, Any}","page":"APIs","title":"Graphs.neighbors","text":"neighbors(zwd, v)\n\nReturns a vector of vertices connected to v.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.nv-Tuple{ZXCalculus.ZW.ZWDiagram}","page":"APIs","title":"Graphs.nv","text":"nv(zwd)\n\nReturns the number of vertices (spiders) of a ZW-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, ZXCalculus.ZW.ZWSpiderType, Vector{T}}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.add_spider!","text":"add_spider!(zwd, spider, connect = [])\n\nAdd a new spider spider with appropriate parameter connected to the half edges connect.\n\nHad to make halfedge class 1 citizen because there will be ambiguity Consider A to B and there are multiple edges to A and from A to B\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.get_input_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZW.get_input_idx","text":"get_input_idx(zwd::ZXWDiagram{T,P}, q::T) where {T,P}\n\nGet spider index of input qubit q.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.get_inputs-Tuple{ZXCalculus.ZW.ZWDiagram}","page":"APIs","title":"ZXCalculus.ZW.get_inputs","text":"get_inputs(zwd)\n\nReturns a vector of input ids.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.get_output_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZW.get_output_idx","text":"get_output_idx(zwd::ZWDiagram{T,P}, q::T) where {T,P}\n\nGet spider index of output qubit q.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.get_outputs-Tuple{ZXCalculus.ZW.ZWDiagram}","page":"APIs","title":"ZXCalculus.ZW.get_outputs","text":"get_outputs(zwd)\n\nReturns a vector of output ids.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T, ZXCalculus.ZW.ZWSpiderType}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.insert_spider!","text":"insert_spider!(zwd, he1, spider)\n\nInsert a spider spider with appropriate parameter on the half-edge prior to he1. v1 <- he1 - v2 becomes v1 <- he1 - v2 <- henew - vnew\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.nout-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZW.nout","text":"nout(zwd)\n\nReturns the number of outputs of a ZW-diagram\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.nqubits-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}","page":"APIs","title":"ZXCalculus.ZW.nqubits","text":"nqubits(zwd)\n\nReturns the qubit number of a ZW-diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.parameter-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.parameter","text":"parameter(zwd, v)\n\nReturns the parameter of a spider. If the spider is not a monoZ or binZ spider, then return 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.print_spider-Union{Tuple{P}, Tuple{T}, Tuple{IO, ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.print_spider","text":"print_spider(io, zwd, v)\n\nPrint a spider to io.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.round_phases!-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.round_phases!","text":"round_phases!(zwd)\n\nRound phases between [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T, ZXCalculus.Utils.Parameter}} where {T, P}","page":"APIs","title":"ZXCalculus.ZW.set_phase!","text":"set_phase!(zwd, v, p)\n\nSet the phase of v in zwd to p. If v is not a monoZ or binZ spider, then do nothing. If v is not in zwd, then return false to indicate failure.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.spider_type","text":"spider_type(zwd, v)\n\nReturns the spider type of a spider if it exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZX.spiders-Tuple{ZXCalculus.ZW.ZWDiagram}","page":"APIs","title":"ZXCalculus.ZX.spiders","text":"spiders(zwd::ZWDiagram)\n\nReturns a vector of spider idxs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.ZW.ZWDiagram-Union{Tuple{P}, Tuple{T}, Tuple{T, Type{P}}} where {T<:Integer, P}","page":"APIs","title":"ZXCalculus.ZW.ZWDiagram","text":"ZWDiagram(nbits::T, ::Type{P}) where {T<:Integer}\n\nCreate a ZW-diagram with nbits input and output qubits.\n\nScalar is parameterized to be P.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.Utils.Parameter","page":"APIs","title":"ZXCalculus.Utils.Parameter","text":"Parameter\n\nThe Algebraic Data Type for representing parameter related to spider. PiUnit(x) represents the the phase of a number exp(im*x*π). Factor(x) represents a number x.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.Utils.Parameter-Union{Tuple{Val{:PiUnit}}, Tuple{T}, Tuple{Val{:PiUnit}, T}} where T","page":"APIs","title":"ZXCalculus.Utils.Parameter","text":"Parameter Constructors for Parameter type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.Utils.Phase","page":"APIs","title":"ZXCalculus.Utils.Phase","text":"Phase\n\nThe type supports manipulating phases as expressions. Phase(x) represents the number x⋅π.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.Utils.Scalar","page":"APIs","title":"ZXCalculus.Utils.Scalar","text":"Scalar\n\nA struct for recording the scalars when we rewrite ZX-diagrams.\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.PMG.add_facet_to_boarder!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.add_facet_to_boarder!","text":"add_facet_to_boarder!(pmg::PlanarMultigraph{T}, h::T, g::T) where {T<:Integer}\n\nCreates a facet with edge connecting the destination of h and g.\n\nh and g needs to be in ccw order\n\nReference\n\nCGAL\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.add_vertex_and_facet_to_boarder!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.add_vertex_and_facet_to_boarder!","text":"add_vertex_and_facet_to_boarder!(\npmg::PlanarMultigraph{T},\nh::T,\ng::T,\n\n) where {T<:Integer}\n\nTBW\n\nReference\n\nCGAl\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.create_edge!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.create_edge!","text":"create_edge!(pmg::PlanarMultigraph{T}, vs::T, vd::T) where {T<:Integer}\n\nCreate an a pair of halfedge from vs to vd, add to PlanarMultigraph pmg. Facet information is not updated yet but set to default value of 0. Vertex to halfedge is updated and set to the two newly added half edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.create_face!-Union{Tuple{ZXCalculus.PMG.PlanarMultigraph{T}}, Tuple{T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.create_face!","text":"create_face!(pmg::PlanarMultigraph{T}) where {T<:Integer}\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.create_vertex!-Union{Tuple{ZXCalculus.PMG.PlanarMultigraph{T}}, Tuple{T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.create_vertex!","text":"create_vertex!(g::PlanarMultigraph{T}; mul::Int = 1) where {T<:Integer}\n\nCreate vertices.\n\nCreate mul of vertices and record them in PlanarMultigraph g's v_max field.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.erase_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.erase_facet!","text":"erase_facet!(pmg::PlanarMultigraph{T}, h::T)\n\nErase the facet incident on h.\n\nReference\n\nCGAL Library\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.gc_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, Vector{T}}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.gc_vertex!","text":"gc_vertex!(pmg::PlanarMultigraph{T}, vs::Vector{T}) where {T<:Integer}\n\nGarbage collect vertices that's no longer connected to any edge.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.is_boundary-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.is_boundary","text":"is_boundary(g::PlanarMultigraph{T}, he_id::T) where {T}\n\nIf the half edge is on the boundary of entire manifold\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.join_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.join_facet!","text":"join_facet!(pmg::PlanarMultigraph{T}, h::T) where {T}\n\nJoin two facets incident to h and it's twin into one.\n\nThe facet incident to h's twin is removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.join_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.join_vertex!","text":"join_vertex!(pmg::PlanarMultigraph{T}, h::T) where {T<:Integer}\n\nJoin two vertices connected by a HalfEdge into one.\n\nProvides the removal of an edge.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.make_hole!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.make_hole!","text":"make_hole!(pmg::PlanarMultigraph{T}, h::T) where {T<:Integer}\n\nConvert the facet incident to a half edge into a hole.\n\nMakes all the half edges in the facet a boundary halfedge.\n\nReference\n\nCGAL\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.n_conn_comp-Tuple{ZXCalculus.PMG.PlanarMultigraph}","page":"APIs","title":"ZXCalculus.PMG.n_conn_comp","text":"n_conn_comp(g::PlanarMultigraph)\n\nReturn the number of connected components.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.new_edge-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.new_edge","text":"new_edge(src::T, dst::T) where {T<:Integer}\n\nCreate a half edge and its twin\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.out_half_edge-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.out_half_edge","text":"out_half_edge(g::PlanarMultigraph{T}, v::T)\n\nGet the one out half edge of a vertex\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.prev-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.prev","text":"prev(g::PlanarMultigraph{T}, he_id::T) where {T<:Integer}\n\nProvides Previous Half Edge of a facet. HDS is bidi\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.split_edge!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.split_edge!","text":"split_edge!(pmg::PlanarMultigraph{T}, h::T) where {T<:Integer}\n\nSplit an edge into two consecutive ones. 1->2->3 becomes 1->4->2->3\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.split_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.split_facet!","text":"split_facet!(pmg::PlanarMultigraph{T}, h::T, g::T) where {T<:Integer}\n\nSplit a facet incident to h and g into two facets.\n\nPrecondition\n\nh and g are in the same facet\nh and g are not the same half edge\nCannot be used to split the faces incident to the multiedge.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.split_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T<:Integer","page":"APIs","title":"ZXCalculus.PMG.split_vertex!","text":"split_vertex!(g::PlanarMultigraph{T}, he1::T, he2::T) where {T<:Integer}\n\nSplit a vertex into 2 vertices.\n\nConnect the two vertices with a new pair of half edges. he1 and he2 are half edges that marks the start and end of half edges that remain on v1.\n\nAfter splitting, h points to the newly added vertex\n\nReference\n\nCGAL\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.surrounding_half_edge-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.surrounding_half_edge","text":"surrounding_half_edge(g::PlanarMultigraph{T}, f::T)\n\nGet the one surrounding half edge of a face\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.trace_face-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.trace_face","text":"trace_face(g::PlanarMultigraph{T}, f::T; safe_trace = false) where {T}\n\nReturn the half edges of a face.\n\nIf safe_trace is true, then the half edges are returned in scrambled order. Otherwise, the returned half edges are in counter clockwise order but is not guaranteed to be consitent with he2f.\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.σ-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.σ","text":"σ(g::PlanarMultigraph{T}, he_id::T) where {T}\n\nGet prevatsource\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.σ_inv-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.σ_inv","text":"σ_inv(pmg::PlanarMultigraph{T}, h::T) where {T}\n\nGet nextatsource, clockwise\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.ϕ-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T","page":"APIs","title":"ZXCalculus.PMG.ϕ","text":"ϕ(g::PlanarMultigraph{T}, he_id::T) where {T}\n\nGet twin half edge id\n\n\n\n\n\n","category":"method"},{"location":"api/#ZXCalculus.PMG.HalfEdge","page":"APIs","title":"ZXCalculus.PMG.HalfEdge","text":"HalfEdge{T<:Integer}(src ,dst)\n\nDatatype to represent a Half Edge\n\nReference\n\nBrönnimann, Hervé [Designing and Implementing a General Purpose Halfedge Data Structure]\n\n(https://doi.org/10.1007/3-540-44688-5_5)\n\nCGAL Library HalfEdge Data Structure\n\n\n\n\n\n","category":"type"},{"location":"api/#ZXCalculus.PMG.PlanarMultigraph","page":"APIs","title":"ZXCalculus.PMG.PlanarMultigraph","text":"PlanarMultigraph{T<:Integer}\n\nImplements a planar multigraph with a maximal HDS Structure.\n\nFeatures\n\nStores Forward Half Edge pointer in facet\nVertex linked\nFace Linked\n\nReferences:\n\nOur implementation is based heavily on the CGAL Library. A good introduction on the HDS Structure and the Polyhedron3 Object which gives the boundary representation of a 2-manifold can be found in this paper.\n\nTODO: Proof of Completeness for Euler Operations with Preconditions In the\n\nCGAL Library, the Euler Operations are implemented with preconditions. It was pointed out that Euler Operations are closed for orientable 2-manifolds in paper where the detailed proof is in book. It was further pointed out in paper that Euler Operations are complete in Theorem 4.4.\n\nThe question remains whether the completeness remains for the preconditions attached. One way of proving is to show that for the Euler Operations used in Theorem 4.4, we could always construct them out of the Euler Operations in CGAL Library with preconditions?\n\n\n\n\n\n","category":"type"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ZX-diagrams are the basic objects in ZX-calculus. In our implementation, each ZX-diagram consists of a multigraph and vertices information including the type of vertices and the phase of vertices. ZXCalculus.ZX.ZXDiagram is the data structure for representing ZX-diagrams.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are 5 types of vertices: In, Out, Z, X, H which represent the inputs of quantum circuits, outputs of quantum circuits, Z-spiders, X-spiders, H-boxes. There can be a phase for each vertex. The phase of a vertex of Z or X is the phase of a Z or X-spider. For the other types of vertices, the phase is zero by default.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In each ZXDiagram, there is a layout for storing layout information for the quantum circuit, and a phase_ids for storing information which is needed in phase teleportation.","category":"page"},{"location":"tutorials/#Construction-of-ZX-diagrams","page":"Tutorials","title":"Construction of ZX-diagrams","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"As we usually focus on quantum circuits, the recommended way to construct ZXDiagrams is by the following function ZXCalculus.ZX.ZXDiagram(nbits::T) where {T<:Integer}.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Then one can use ZXCalculus.ZX.push_gate! to push quantum gates at the end of a quantum circuit, or use ZXCalculus.ZX.pushfirst_gate!to push gates at the beginning of a quantum circuit.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For example, in example\\ex1.jl, one can generate the demo circuit by the function","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using ZXCalculus\nfunction generate_example()\n    zxd = ZXCalculus.ZX.ZXDiagram(4)\n    push_gate!(zxd, Val(:Z), 1, 3//2)\n    push_gate!(zxd, Val(:H), 1)\n    push_gate!(zxd, Val(:Z), 1, 1//2)\n    push_gate!(zxd, Val(:Z), 2, 1//2)\n    push_gate!(zxd, Val(:H), 4)\n    push_gate!(zxd, Val(:CNOT), 3, 2)\n    push_gate!(zxd, Val(:CZ), 4, 1)\n    push_gate!(zxd, Val(:H), 2)\n    push_gate!(zxd, Val(:CNOT), 3, 2)\n    push_gate!(zxd, Val(:CNOT), 1, 4)\n    push_gate!(zxd, Val(:H), 1)\n    push_gate!(zxd, Val(:Z), 2, 1//4)\n    push_gate!(zxd, Val(:Z), 3, 1//2)\n    push_gate!(zxd, Val(:H), 4)\n    push_gate!(zxd, Val(:Z), 1, 1//4)\n    push_gate!(zxd, Val(:H), 2)\n    push_gate!(zxd, Val(:H), 3)\n    push_gate!(zxd, Val(:Z), 4, 3//2)\n    push_gate!(zxd, Val(:Z), 3, 1//2)\n    push_gate!(zxd, Val(:X), 4, 1//1)\n    push_gate!(zxd, Val(:CNOT), 3, 2)\n    push_gate!(zxd, Val(:H), 1)\n    push_gate!(zxd, Val(:Z), 4, 1//2)\n    push_gate!(zxd, Val(:X), 4, 1//1)\n\n    return zxd\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In the paper arXiv:1902.03178, they introduced a special type of ZX-diagrams, graph-like ZX-diagrams, which consists of Z-spiders with 2 different types of edges only. We use ZXCalculus.ZX.ZXGraph for representing this special type of ZX-diagrams. One can convert a ZXDiagram into a ZXGraph by simply use the construction function ZXCalculus.ZX.ZXGraph(zxd::ZXCalculus.ZX.ZXDiagram{T, P}) where {T, P}:","category":"page"},{"location":"tutorials/#Visualization","page":"Tutorials","title":"Visualization","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"With the package YaoPlots.jl, one can draw ZX-diagrams with one line of code.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"plot(zxd[; linetype = lt])","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here zxd can be either a ZXDiagram or ZXGraph. The argument lt is set to \"straight\" by default. One can also set it to \"curve\" to make the edges curves.","category":"page"},{"location":"tutorials/#Manipulating-ZX-diagrams","page":"Tutorials","title":"Manipulating ZX-diagrams","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"With ZXCalculus.jl, one can manipulate ZX-diagrams at different levels.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Simplifying quantum circuits\nRewriting ZX-diagrams with rules\nRewriting ZX-diagrams at the graphical level","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The highest level is the circuit simplification algorithms. By now there are two algorithms are available: ZXCalculus.ZX.clifford_simplification and ZXCalculus.ZX.phase_teleportation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The input of these algorithms will be a ZX-diagram representing a quantum circuit. And these algorithms will return a ZX-diagram of a simplified quantum circuit. For more details, please refer to Clifford simplification and phase teleportation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"One can rewrite ZX-diagrams with rules. In ZXCalculus.jl, rules are identified as data structures Rule. And we can use the following functions to simplify ZX-diagrams: ZXCalculus.ZX.simplify! and ZXCalculus.ZX.replace!.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For example, in example/ex1.jl, we can get a simplified graph-like ZX-diagram by:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"zxd = generate_example()\nzxg = ZXGraph(zxd)\nsimplify!(Rule{:lc}(), zxg)\nsimplify!(Rule{:p1}(), zxg)\nreplace!(Rule{:pab}(), zxg)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The difference between simplify! and replace! is that replace! only matches vertices and tries to rewrite with all matched vertices once, while simplify! will keep matching until nothing matched.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The following APIs are useful for more detailed rewriting.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ZXCalculus.ZX.match\nZXCalculus.ZX.rewrite!","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The lowest level for rewriting ZX-diagrams is manipulating the multigraphs directly. This way is not recommended unless one wants to develop new rules in ZX-calculus.","category":"page"},{"location":"tutorials/#Integration-with-YaoLang.jl","page":"Tutorials","title":"Integration with YaoLang.jl","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"YaoLang.jl is the next DSL for Yao and quantum programs. And it is now integrated with ZXCalculus.jl. The compiler of YaoLang.jl will optimize the quantum programs when the optimizers are given.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"One can use","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@device function circuit()\n    ...\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"to build up a generic quantum circuit. To set up a optimizer in addition, one can simply use","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@device optimizer = opt function circuit()\n    ...\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here, opt can be a sub-vector of [:zx_clifford, :zx_teleport]. That is, if :zx_clifford is in opt, then clifford_simplification will be applied to the circuit, and if :zx_teleport is in opt, then phase_teleportation will be applied to the circuit.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For example, the following code will try to simplify circ that defined by circuit() with clifford_simplification and phase_teleportation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@device optimizer = [:zx_clifford, :zx_teleport] function circuit()\n    ...\nend\ncirc = circuit()","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we will show some examples of using ZXCalculus.jl.","category":"page"},{"location":"examples/#Clifford-simplification","page":"Examples","title":"Clifford simplification","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example can be found in the appendix of Clifford simplification. Firstly, we build up the circuit by using push_gate!.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ZXCalculus\n\nfunction generate_example_1()\n    zxd = ZXDiagram(4)\n    push_gate!(zxd, Val(:Z), 1, 3//2)\n    push_gate!(zxd, Val(:H), 1)\n    push_gate!(zxd, Val(:Z), 1, 1//2)\n    push_gate!(zxd, Val(:H), 4)\n    push_gate!(zxd, Val(:CZ), 4, 1)\n    push_gate!(zxd, Val(:CNOT), 1, 4)\n    push_gate!(zxd, Val(:H), 1)\n    push_gate!(zxd, Val(:H), 4)\n    push_gate!(zxd, Val(:Z), 1, 1//4)\n    push_gate!(zxd, Val(:Z), 4, 3//2)\n    push_gate!(zxd, Val(:X), 4, 1//1)\n    push_gate!(zxd, Val(:H), 1)\n    push_gate!(zxd, Val(:Z), 4, 1//2)\n    push_gate!(zxd, Val(:X), 4, 1//1)\n    push_gate!(zxd, Val(:Z), 2, 1//2)\n    push_gate!(zxd, Val(:CNOT), 3, 2)\n    push_gate!(zxd, Val(:H), 2)\n    push_gate!(zxd, Val(:CNOT), 3, 2)\n    push_gate!(zxd, Val(:Z), 2, 1//4)\n    push_gate!(zxd, Val(:Z), 3, 1//2)\n    push_gate!(zxd, Val(:H), 2)\n    push_gate!(zxd, Val(:H), 3)\n    push_gate!(zxd, Val(:Z), 3, 1//2)\n    push_gate!(zxd, Val(:CNOT), 3, 2)\n\n    return zxd\nend\nex1 = generate_example_1()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can draw this ZX-diagram by using","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using YaoPlots\nplot(ex1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: the circuit of example 1) To simplify zxd, one can simply use","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"simplified_ex1 = clifford_simplification(ex1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"or explicitly use","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"zxg = ZXGraph(ex1)\nsimplify!(Rule{:lc}(), zxg)\nsimplify!(Rule{:p1}(), zxg)\nreplace!(Rule{:pab}(), zxg)\nsimplified_ex1 = circuit_extraction(zxg)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And we draw the simplified circuit.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(simplified_ex1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: the simplified circuit of example 1)","category":"page"},{"location":"examples/#Phase-teleportation","page":"Examples","title":"Phase teleportation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is an arithmetic circuit from phase teleportation. We first build up the circuit.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ZXCalculus, YaoPlots\nfunction generate_example2()\n    cir = ZXDiagram(5)\n    push_gate!(cir, Val(:X), 5, 1//1)\n    push_gate!(cir, Val(:H), 5)\n    push_gate!(cir, Val(:Z), 5)\n    push_gate!(cir, Val(:CNOT), 5, 4)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 1)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:CNOT), 5, 4)\n    push_gate!(cir, Val(:Z), 4, 1//4)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 1)\n    push_gate!(cir, Val(:CNOT), 4, 1)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:Z), 1, 1//4)\n    push_gate!(cir, Val(:Z), 4, 7//4)\n    push_gate!(cir, Val(:CNOT), 4, 1)\n    push_gate!(cir, Val(:CNOT), 5, 4)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 3)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:CNOT), 5, 4)\n    push_gate!(cir, Val(:Z), 4, 1//4)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 3)\n    push_gate!(cir, Val(:CNOT), 4, 3)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:Z), 3, 1//4)\n    push_gate!(cir, Val(:Z), 4, 7//4)\n    push_gate!(cir, Val(:H), 5)\n    push_gate!(cir, Val(:Z), 5)\n    push_gate!(cir, Val(:CNOT), 4, 3)\n    push_gate!(cir, Val(:CNOT), 5, 4)\n    push_gate!(cir, Val(:H), 5)\n    push_gate!(cir, Val(:Z), 5)\n    push_gate!(cir, Val(:CNOT), 5, 3)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 2)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:CNOT), 5, 3)\n    push_gate!(cir, Val(:Z), 3, 1//4)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 2)\n    push_gate!(cir, Val(:CNOT), 3, 2)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:H), 5)\n    push_gate!(cir, Val(:Z), 2, 1//4)\n    push_gate!(cir, Val(:Z), 3, 7//4)\n    push_gate!(cir, Val(:Z), 5)\n    push_gate!(cir, Val(:CNOT), 3, 2)\n    push_gate!(cir, Val(:CNOT), 5, 3)\n    push_gate!(cir, Val(:H), 5)\n    push_gate!(cir, Val(:Z), 5)\n    push_gate!(cir, Val(:CNOT), 5, 2)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 1)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:CNOT), 5, 2)\n    push_gate!(cir, Val(:Z), 2, 1//4)\n    push_gate!(cir, Val(:Z), 5, 7//4)\n    push_gate!(cir, Val(:CNOT), 5, 1)\n    push_gate!(cir, Val(:CNOT), 2, 1)\n    push_gate!(cir, Val(:Z), 5, 1//4)\n    push_gate!(cir, Val(:Z), 1, 1//4)\n    push_gate!(cir, Val(:Z), 2, 7//4)\n    push_gate!(cir, Val(:H), 5)\n    push_gate!(cir, Val(:Z), 5)\n    push_gate!(cir, Val(:CNOT), 2, 1)\n    push_gate!(cir, Val(:CNOT), 5, 2)\n    push_gate!(cir, Val(:CNOT), 5, 1)\n    return cir\nend\nex2 = generate_example2()\nplot(ex2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: the circuit of example 2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use phase_teleportation for reducing the number of T gates of a circuit without changing its general structure.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"reduced_ex2 = phase_teleportation(ex2)\nplot(reduced_ex2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: the reduced circuit of example 2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By using tcount,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"tcount(ex2)\ntcount(reduced_ex2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"we can see that the number of T gates has decreased from 28 to 8.","category":"page"},{"location":"examples/#Other-usages","page":"Examples","title":"Other usages","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the previous sections, we introduced how to use ZXCalculus.jl for ZX-diagrams which represent quantum circuits. Sometimes, one may wish to use it for general ZX-diagrams. It is possible.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"One can create a ZXDiagram by building up its Multigraph and other information. For example,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ZXCalculus, YaoPlots, Graphs\ng = Multigraph(6)\nadd_edge!(g, 1, 2)\nadd_edge!(g, 2, 3)\nadd_edge!(g, 3, 4)\nadd_edge!(g, 3, 5)\nadd_edge!(g, 3, 6)\nps = [0, 1, 1//2, 0, 0, 0]\nv_t = [SpiderType.In, SpiderType.X, SpiderType.Z, SpiderType.Out, SpiderType.Out, SpiderType.Out]\nzxd = ZXDiagram(g, v_t, ps)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because the information of vertices locations of a general ZX-diagram is not provided, its plot will have a random layout.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can manipulate zxd by using ZX-calculus Rules.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"matches = match(Rule{:pi}(), zxd)\nrewrite!(Rule{:pi}(), zxd, matches)","category":"page"},{"location":"#ZXCalculus.jl","page":"Home","title":"ZXCalculus.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A implementation of ZX-calculus in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ZX-calculus is a graphical language for quantum computing. One can represent quantum states and operators as ZX-diagrams, and manipulate them with ZX-calculus rules. As an application of ZX-calculus, one can simplify quantum circuits with it. For more details about ZX-calculus, one can check this website.","category":"page"},{"location":"#GSoC","page":"Home","title":"GSoC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a Google Summer of Code 2020 project.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As an implementation of ZX-calculus, these following features are available similar to the Python implementation PyZX.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building up and manipulating ZX-diagrams\nSimplifying ZX-diagrams with specific rules\nSimplifying quantum circuits with ZX-calculus based algorithms including Clifford simplification and phase teleportation.\nVisualization for ZX-diagrams.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ZXCalculus.jl can be integrated into the quantum compiler YaoLang.jl. This makes the following features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reading or outputting quantum circuits in various forms (for example, QASM, YaoBlock instructions, and so on).\nA compiler level circuit simplification engine.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ZXCalculus.jl, please open Julia's interactive session (known as REPL) and press ] key in the REPL to use the package mode, then type the following command","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ZXCalculus","category":"page"},{"location":"","page":"Home","title":"Home","text":"For plotting, please install YaoPlots.jl in addition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add YaoPlots","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorials.md\", \"examples.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
