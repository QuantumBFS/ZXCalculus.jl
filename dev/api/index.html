<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>APIs · ZXCalculus.jl</title><meta name="title" content="APIs · ZXCalculus.jl"/><meta property="og:title" content="APIs · ZXCalculus.jl"/><meta property="twitter:title" content="APIs · ZXCalculus.jl"/><meta name="description" content="Documentation for ZXCalculus.jl."/><meta property="og:description" content="Documentation for ZXCalculus.jl."/><meta property="twitter:description" content="Documentation for ZXCalculus.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ZXCalculus.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>APIs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>APIs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https:/github.com/QuantumBFS/ZXCalculus.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="APIs"><a class="docs-heading-anchor" href="#APIs">APIs</a><a id="APIs-1"></a><a class="docs-heading-anchor-permalink" href="#APIs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram{T, P}}} where {T, P}" href="#Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram{T, P}}} where {T, P}"><code>Base.match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match(r, zxd)</code></pre><p>Returns all matched vertices, which will be store in sturct <code>Match</code>, for rule <code>r</code> in a ZX-diagram <code>zxd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.replace!-Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram}" href="#Base.replace!-Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram}"><code>Base.replace!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace!(r, zxd)</code></pre><p>Match and replace with the rule <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.ne-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#Graphs.ne-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(zxd; count_mul = false)</code></pre><p>Returns the number of edges of a ZX-diagram. If <code>count_mul</code>, it will return the sum of multiplicities of all multiple edges. Otherwise, it will return the number of multiple edges.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.neighbors-Tuple{ZXCalculus.ZX.ZXDiagram, Any}" href="#Graphs.neighbors-Tuple{ZXCalculus.ZX.ZXDiagram, Any}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(zxd, v; count_mul = false)</code></pre><p>Returns a vector of vertices connected to <code>v</code>. If <code>count_mul</code>, there will be multiple copy for each vertex. Otherwise, each vertex will only appear once.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.nv-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#Graphs.nv-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(zxd)</code></pre><p>Returns the number of vertices (spiders) of a ZX-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType, P}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType, P, Vector{T}}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType, P}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, ZXCalculus.ZX.SpiderType.SType, P, Vector{T}}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.add_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_spider!(zxd, spider_type, phase = 0, connect = [])</code></pre><p>Add a new spider which is of the type <code>spider_type</code> with phase <code>phase</code> and connected to the vertices <code>connect</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ancilla_extraction-Tuple{ZXCalculus.ZX.ZXGraph}" href="#ZXCalculus.ZX.ancilla_extraction-Tuple{ZXCalculus.ZX.ZXGraph}"><code>ZXCalculus.ZX.ancilla_extraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ancilla_extraction(zxg::ZXGraph) -&gt; ZXDiagram</code></pre><p>Extract a quantum circuit from a general <code>ZXGraph</code> even without a gflow.  It will introduce post-selection operators.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.biadjacency-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, Vector{T}, Vector{T}}} where {T, P}" href="#ZXCalculus.ZX.biadjacency-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, Vector{T}, Vector{T}}} where {T, P}"><code>ZXCalculus.ZX.biadjacency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">biadjacency(zxg, F, N)</code></pre><p>Return the biadjacency matrix of <code>zxg</code> from vertices in <code>F</code> to vertices in <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.circuit_extraction-Union{Tuple{ZXCalculus.ZX.ZXGraph{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZX.circuit_extraction-Union{Tuple{ZXCalculus.ZX.ZXGraph{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZX.circuit_extraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circuit_extraction(zxg::ZXGraph)</code></pre><p>Extract circuit from a graph-like ZX-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.clifford_simplification-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#ZXCalculus.ZX.clifford_simplification-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>ZXCalculus.ZX.clifford_simplification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clifford_simplification(zxd)</code></pre><p>Simplify <code>zxd</code> with the algorithms in <a href="https://arxiv.org/abs/1902.03178">arXiv:1902.03178</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.column_loc-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T}} where T" href="#ZXCalculus.ZX.column_loc-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T}} where T"><code>ZXCalculus.ZX.column_loc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">column_loc(layout, v)</code></pre><p>Return the column number corresponding to the spider <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.continued_fraction-Tuple{Any, Int64}" href="#ZXCalculus.ZX.continued_fraction-Tuple{Any, Int64}"><code>ZXCalculus.ZX.continued_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">continued_fraction(ϕ, n::Int) -&gt; Rational</code></pre><p>Obtain <code>s</code> and <code>r</code> from <code>ϕ</code> that satisfies <code>|s//r - ϕ| ≦ 1/2r²</code></p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.gaussian_elimination-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Vector{ZXCalculus.ZX.GEStep}}} where T&lt;:Integer" href="#ZXCalculus.ZX.gaussian_elimination-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Vector{ZXCalculus.ZX.GEStep}}} where T&lt;:Integer"><code>ZXCalculus.ZX.gaussian_elimination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussian_elimination(M[, steps])</code></pre><p>Return result and steps of Gaussian elimination of matrix <code>M</code>. Here we assume that the elements of <code>M</code> is in binary field F_2 = {0,1}.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.get_inputs-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#ZXCalculus.ZX.get_inputs-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>ZXCalculus.ZX.get_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_inputs(zxd)</code></pre><p>Returns a vector of input ids.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.get_outputs-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#ZXCalculus.ZX.get_outputs-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>ZXCalculus.ZX.get_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_outputs(zxd)</code></pre><p>Returns a vector of output ids.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, T, ZXCalculus.ZX.SpiderType.SType}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, T, ZXCalculus.ZX.SpiderType.SType, P}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, T, ZXCalculus.ZX.SpiderType.SType}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, T, ZXCalculus.ZX.SpiderType.SType, P}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.insert_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert_spider!(zxd, v1, v2, spider_type, phase = 0)</code></pre><p>Insert a spider of the type <code>spider_type</code> with phase = <code>phase</code>, between two vertices <code>v1</code> and <code>v2</code>. It will insert multiple times if the edge between <code>v1</code> and <code>v2</code> is a multiple edge. Also it will remove the original edge between <code>v1</code> and <code>v2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.is_interior-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, T}} where {T, P}" href="#ZXCalculus.ZX.is_interior-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, T}} where {T, P}"><code>ZXCalculus.ZX.is_interior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_interior(zxg::ZXGraph, v)</code></pre><p>Return <code>true</code> if <code>v</code> is a interior spider of <code>zxg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.nqubits-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#ZXCalculus.ZX.nqubits-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>ZXCalculus.ZX.nqubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nqubits(zxd)</code></pre><p>Returns the qubit number of a ZX-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.phase-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.phase-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(zxd, v)</code></pre><p>Returns the phase of a spider. If the spider is not a Z or X spider, then return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.phase_teleportation-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZX.phase_teleportation-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZX.phase_teleportation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase_teleportation(zxd)</code></pre><p>Reducing T-count of <code>zxd</code> with the algorithms in <a href="https://arxiv.org/abs/1903.10477">arXiv:1903.10477</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.push_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T, Any}} where {T, P}" href="#ZXCalculus.ZX.push_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T, Any}} where {T, P}"><code>ZXCalculus.ZX.push_gate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push_gate!(zxd, ::Val{M}, locs...[, phase]; autoconvert=true)</code></pre><p>Push an <code>M</code> gate to the end of qubit <code>loc</code> where <code>M</code> can be <code>:Z</code>, <code>:X</code>, <code>:H</code>, <code>:SWAP</code>, <code>:CNOT</code> and <code>:CZ</code>. If <code>M</code> is <code>:Z</code> or <code>:X</code>, <code>phase</code> will be available and it will push a rotation <code>M</code> gate with angle <code>phase * π</code>. If <code>autoconvert</code> is <code>false</code>, the input <code>phase</code> should be a rational numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.pushfirst_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T, P}} where {T, P}" href="#ZXCalculus.ZX.pushfirst_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Val{:Z}, T, P}} where {T, P}"><code>ZXCalculus.ZX.pushfirst_gate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pushfirst_gate!(zxd, ::Val{M}, loc[, phase])</code></pre><p>Push an <code>M</code> gate to the beginning of qubit <code>loc</code> where <code>M</code> can be <code>:Z</code>, <code>:X</code>, <code>:H</code>, <code>:SWAP</code>, <code>:CNOT</code> and <code>:CZ</code>. If <code>M</code> is <code>:Z</code> or <code>:X</code>, <code>phase</code> will be available and it will push a rotation <code>M</code> gate with angle <code>phase * π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.qubit_loc-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T}} where T" href="#ZXCalculus.ZX.qubit_loc-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T}} where T"><code>ZXCalculus.ZX.qubit_loc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qubit_loc(layout, v)</code></pre><p>Return the qubit number corresponding to the spider <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.rem_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.rem_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.rem_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_spider!(zxd, v)</code></pre><p>Remove a spider indexed by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.rem_spiders!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Vector{T}}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.rem_spiders!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, Vector{T}}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.rem_spiders!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_spiders!(zxd, vs)</code></pre><p>Remove spiders indexed by <code>vs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.rewrite!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram{T, P}, Array{ZXCalculus.ZX.Match{T}, 1}}} where {T, P}" href="#ZXCalculus.ZX.rewrite!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram{T, P}, Array{ZXCalculus.ZX.Match{T}, 1}}} where {T, P}"><code>ZXCalculus.ZX.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(r, zxd, matches)</code></pre><p>Rewrite a ZX-diagram <code>zxd</code> with rule <code>r</code> for all vertices in <code>matches</code>. <code>matches</code> can be a vector of <code>Match</code> or just an instance of <code>Match</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.round_phases!-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.round_phases!-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.round_phases!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_phases!(zxd)</code></pre><p>Round phases between [0, 2π).</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.scalar-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#ZXCalculus.ZX.scalar-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>ZXCalculus.ZX.scalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scalar(zxd)</code></pre><p>Returns the scalar of <code>zxd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.set_column!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any}} where T" href="#ZXCalculus.ZX.set_column!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any}} where T"><code>ZXCalculus.ZX.set_column!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_qubit!(layout, v, q)</code></pre><p>Set the column number of the spider <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.set_loc!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any, Any}} where T" href="#ZXCalculus.ZX.set_loc!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any, Any}} where T"><code>ZXCalculus.ZX.set_loc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_loc!(layout, v, q, col)</code></pre><p>Set the location of the spider <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, P}} where {T, P}" href="#ZXCalculus.ZX.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T, P}} where {T, P}"><code>ZXCalculus.ZX.set_phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_phase!(zxd, v, p)</code></pre><p>Set the phase of <code>v</code> in <code>zxd</code> to <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.set_qubit!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any}} where T" href="#ZXCalculus.ZX.set_qubit!-Union{Tuple{T}, Tuple{ZXCalculus.ZX.ZXLayout{T}, T, Any}} where T"><code>ZXCalculus.ZX.set_qubit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_qubit!(layout, v, q)</code></pre><p>Set the qubit number of the spider <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.simplify!-Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram}" href="#ZXCalculus.ZX.simplify!-Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZX.AbstractZXDiagram}"><code>ZXCalculus.ZX.simplify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify!(r, zxd)</code></pre><p>Simplify <code>zxd</code> with the rule <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.spider_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spider_type(zxd, v)</code></pre><p>Returns the spider type of a spider.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.tcount-Tuple{ZXCalculus.ZX.ZXDiagram}" href="#ZXCalculus.ZX.tcount-Tuple{ZXCalculus.ZX.ZXDiagram}"><code>ZXCalculus.ZX.tcount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tcount(zxd)</code></pre><p>Returns the T-count of a ZX-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.update_frontier!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, Set{T}, Vector{T}, Dict{T, Int64}, Any}} where {T, P}" href="#ZXCalculus.ZX.update_frontier!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.ZXGraph{T, P}, Set{T}, Vector{T}, Dict{T, Int64}, Any}} where {T, P}"><code>ZXCalculus.ZX.update_frontier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_frontier!(zxg, frontier, qubit_map, cir)</code></pre><p>Update frontier. This is an important step in the circuit extraction algorithm. For more detail, please check the paper <a href="https://arxiv.org/abs/1902.03178">arXiv:1902.03178</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.GEStep" href="#ZXCalculus.ZX.GEStep"><code>ZXCalculus.ZX.GEStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GEStep</code></pre><p>A struct for representing steps in the Gaussian elimination.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.Match" href="#ZXCalculus.ZX.Match"><code>ZXCalculus.ZX.Match</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Match{T&lt;:Integer}</code></pre><p>A struct for saving matched vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.Rule" href="#ZXCalculus.ZX.Rule"><code>ZXCalculus.ZX.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rule{L}</code></pre><p>The struct for identifying different rules.</p><p>Rule for <code>ZXDiagram</code>s:</p><ul><li><code>Rule{:f}()</code>: rule f</li><li><code>Rule{:h}()</code>: rule h</li><li><code>Rule{:i1}()</code>: rule i1</li><li><code>Rule{:i2}()</code>: rule i2</li><li><code>Rule{:pi}()</code>: rule π</li><li><code>Rule{:c}()</code>: rule c</li></ul><p>Rule for <code>ZXGraph</code>s:</p><ul><li><code>Rule{:lc}()</code>: local complementary rule</li><li><code>Rule{:p1}()</code>: pivoting rule</li><li><code>Rule{:pab}()</code>: rule for removing Pauli spiders adjancent to boundary spiders</li><li><code>Rule{:p2}()</code>: rule p2</li><li><code>Rule{:p3}()</code>: rule p3</li><li><code>Rule{:id}()</code>: rule id</li><li><code>Rule{:gf}()</code>: gadget fushion rule</li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ZXDiagram" href="#ZXCalculus.ZX.ZXDiagram"><code>ZXCalculus.ZX.ZXDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZXDiagram{T, P}</code></pre><p>This is the type for representing ZX-diagrams.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ZXDiagram-Tuple{T} where T&lt;:Integer" href="#ZXCalculus.ZX.ZXDiagram-Tuple{T} where T&lt;:Integer"><code>ZXCalculus.ZX.ZXDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZXDiagram(nbits)</code></pre><p>Construct a ZXDiagram of a empty circuit with qubit number <code>nbit</code></p><pre><code class="language-julia-repl hljs">julia&gt; zxd = ZXDiagram(3)
ZX-diagram with 6 vertices and 3 multiple edges:
(S_1{input} &lt;-1-&gt; S_2{output})
(S_3{input} &lt;-1-&gt; S_4{output})
(S_5{input} &lt;-1-&gt; S_6{output})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ZXDiagram-Union{Tuple{P}, Tuple{T}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}, ZXCalculus.ZX.ZXLayout{T}}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}, ZXCalculus.ZX.ZXLayout{T}, Dict{T, Tuple{T, Int64}}}} where {T, P}" href="#ZXCalculus.ZX.ZXDiagram-Union{Tuple{P}, Tuple{T}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}, ZXCalculus.ZX.ZXLayout{T}}, Tuple{Multigraph{T}, Dict{T, ZXCalculus.ZX.SpiderType.SType}, Dict{T, P}, ZXCalculus.ZX.ZXLayout{T}, Dict{T, Tuple{T, Int64}}}} where {T, P}"><code>ZXCalculus.ZX.ZXDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZXDiagram(mg::Multigraph{T}, st::Dict{T, SpiderType.SType}, ps::Dict{T, P},
    layout::ZXLayout{T} = ZXLayout{T}(),
    phase_ids::Dict{T,Tuple{T, Int}} = Dict{T,Tuple{T,Int}}()) where {T, P}
ZXDiagram(mg::Multigraph{T}, st::Vector{SpiderType.SType}, ps::Vector{P},
    layout::ZXLayout{T} = ZXLayout{T}()) where {T, P}</code></pre><p>Construct a ZXDiagram with all information.</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs, Multigraphs, ZXCalculus.ZX;

julia&gt; using ZXCalculus.ZX.SpiderType: In, Out, H, Z, X;

julia&gt; mg = Multigraph(5);

julia&gt; for i = 1:4
           add_edge!(mg, i, i+1)
       end;

julia&gt; ZXDiagram(mg, [In, Z, H, X, Out], [0//1, 1, 0, 1//2, 0])
ZX-diagram with 5 vertices and 4 multiple edges:
(S_1{input} &lt;-1-&gt; S_2{phase = 1//1⋅π})
(S_2{phase = 1//1⋅π} &lt;-1-&gt; S_3{H})
(S_3{H} &lt;-1-&gt; S_4{phase = 1//2⋅π})
(S_4{phase = 1//2⋅π} &lt;-1-&gt; S_5{output})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ZXGraph" href="#ZXCalculus.ZX.ZXGraph"><code>ZXCalculus.ZX.ZXGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZXGraph{T, P}</code></pre><p>This is the type for representing the graph-like ZX-diagrams.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ZXGraph-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZX.ZXGraph-Union{Tuple{ZXCalculus.ZX.ZXDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZX.ZXGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZXGraph(zxd::ZXDiagram)</code></pre><p>Convert a ZX-diagram to graph-like ZX-diagram.</p><pre><code class="language-julia-repl hljs">julia&gt; using ZXCalculus.ZX

julia&gt; zxd = ZXDiagram(2); push_gate!(zxd, Val{:CNOT}(), 2, 1);

julia&gt; zxg = ZXGraph(zxd)
ZX-graph with 6 vertices and 5 edges:
(S_1{input} &lt;-&gt; S_5{phase = 0//1⋅π})
(S_2{output} &lt;-&gt; S_5{phase = 0//1⋅π})
(S_3{input} &lt;-&gt; S_6{phase = 0//1⋅π})
(S_4{output} &lt;-&gt; S_6{phase = 0//1⋅π})
(S_5{phase = 0//1⋅π} &lt;-&gt; S_6{phase = 0//1⋅π})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.ZXLayout" href="#ZXCalculus.ZX.ZXLayout"><code>ZXCalculus.ZX.ZXLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZXLayout</code></pre><p>A struct for the layout information of <code>ZXDiagram</code> and <code>ZXGraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}" href="#Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}"><code>Base.match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match(r, zxwd)</code></pre><p>Returns all matched vertices, which will be store in sturct <code>Match</code>, for rule <code>r</code> in a ZXW-diagram <code>zxwd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.Rule{:s1}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}" href="#Base.match-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.Rule{:s1}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}"><code>Base.match</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Rule that implements both f and s1 rule.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.ne-Tuple{ZXCalculus.ZXW.ZXWDiagram}" href="#Graphs.ne-Tuple{ZXCalculus.ZXW.ZXWDiagram}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(zxwd; count_mul = false)</code></pre><p>Returns the number of edges of a ZXW-diagram. If <code>count_mul</code>, it will return the sum of multiplicities of all multiple edges. Otherwise, it will return the number of multiple edges.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.neighbors-Tuple{ZXCalculus.ZXW.ZXWDiagram, Any}" href="#Graphs.neighbors-Tuple{ZXCalculus.ZXW.ZXWDiagram, Any}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(zxwd, v; count_mul = false)</code></pre><p>Returns a vector of vertices connected to <code>v</code>. If <code>count_mul</code>, there will be multiple copy for each vertex. Otherwise, each vertex will only appear once.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.nv-Tuple{ZXCalculus.ZXW.ZXWDiagram}" href="#Graphs.nv-Tuple{ZXCalculus.ZXW.ZXWDiagram}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(zxwd)</code></pre><p>Returns the number of vertices (spiders) of a ZXW-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.push_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T, Any}} where {T, P}" href="#ZXCalculus.ZX.push_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T, Any}} where {T, P}"><code>ZXCalculus.ZX.push_gate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push_gate!(zxwd, ::Val{M}, locs...[, phase]; autoconvert=true)</code></pre><p>Push an <code>M</code> gate to the end of qubit <code>loc</code> where <code>M</code> can be <code>:Z</code>, <code>:X</code>, <code>:H</code>, <code>:SWAP</code>, <code>:CNOT</code> and <code>:CZ</code>. If <code>M</code> is <code>:Z</code> or <code>:X</code>, <code>phase</code> will be available and it will push a rotation <code>M</code> gate with angle <code>phase * π</code>. If <code>autoconvert</code> is <code>false</code>, the input <code>phase</code> should be a rational numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.pushfirst_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T, P}} where {T, P}" href="#ZXCalculus.ZX.pushfirst_gate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Val{:Z}, T, P}} where {T, P}"><code>ZXCalculus.ZX.pushfirst_gate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pushfirst_gate!(zxwd, ::Val{M}, loc[, phase])</code></pre><p>Push an <code>M</code> gate to the beginning of qubit <code>loc</code> where <code>M</code> can be <code>:Z</code>, <code>:X</code>, <code>:H</code>, <code>:SWAP</code>, <code>:CNOT</code> and <code>:CZ</code>. If <code>M</code> is <code>:Z</code> or <code>:X</code>, <code>phase</code> will be available and it will push a rotation <code>M</code> gate with angle <code>phase * π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.rem_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.rem_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.rem_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_spider!(zxwd, v)</code></pre><p>Remove a spider indexed by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.rem_spiders!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vector{T}}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZX.rem_spiders!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vector{T}}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZX.rem_spiders!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_spiders!(zxwd, vs)</code></pre><p>Remove spiders indexed by <code>vs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.rewrite!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZXW.ZXWDiagram{T, P}, Array{ZXCalculus.ZX.Match{T}, 1}}} where {T, P}" href="#ZXCalculus.ZX.rewrite!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZX.AbstractRule, ZXCalculus.ZXW.ZXWDiagram{T, P}, Array{ZXCalculus.ZX.Match{T}, 1}}} where {T, P}"><code>ZXCalculus.ZX.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(r, zxd, matches)</code></pre><p>Rewrite a ZX-diagram <code>zxd</code> with rule <code>r</code> for all vertices in <code>matches</code>. <code>matches</code> can be a vector of <code>Match</code> or just an instance of <code>Match</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.add_inout!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T, P}" href="#ZXCalculus.ZXW.add_inout!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T, P}"><code>ZXCalculus.ZXW.add_inout!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add input and outputs to diagram</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWSpiderType}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWSpiderType, Vector{T}}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZXW.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWSpiderType}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWSpiderType, Vector{T}}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZXW.add_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_spider!(zxwd, spider, connect = [])</code></pre><p>Add a new spider <code>spider</code> with appropriate parameter connected to the vertices <code>connect</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.concat!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}" href="#ZXCalculus.ZXW.concat!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}"><code>ZXCalculus.ZXW.concat!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Concatenate two ZXWDiagrams, modify d1.</p><p>Remove outputs of d1 and inputs of d2. Then add edges between to vertices that was conntecting to outputs of d1 and inputs of d2. Assuming you don&#39;t concatenate two empty circuit ZXWDiagram</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.dagger-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZXW.dagger-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZXW.dagger</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert ZXWDiagram that represents unitary U to U^†</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.expval_circ!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, String}} where {T, P}" href="#ZXCalculus.ZXW.expval_circ!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, String}} where {T, P}"><code>ZXCalculus.ZXW.expval_circ!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct ZXW Diagram for representing the expectation value circuit</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.get_inputs-Tuple{ZXCalculus.ZXW.ZXWDiagram}" href="#ZXCalculus.ZXW.get_inputs-Tuple{ZXCalculus.ZXW.ZXWDiagram}"><code>ZXCalculus.ZXW.get_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_inputs(zxwd)</code></pre><p>Returns a vector of input ids.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.get_outputs-Tuple{ZXCalculus.ZXW.ZXWDiagram}" href="#ZXCalculus.ZXW.get_outputs-Tuple{ZXCalculus.ZXW.ZXWDiagram}"><code>ZXCalculus.ZXW.get_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_outputs(zxwd)</code></pre><p>Returns a vector of output ids.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.import_edges!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{T, T}}} where {T, P}" href="#ZXCalculus.ZXW.import_edges!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{T, T}}} where {T, P}"><code>ZXCalculus.ZXW.import_edges!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Import edges of d2 to d1, modify d1</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.import_non_in_out!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{T, T}}} where {T, P}" href="#ZXCalculus.ZXW.import_non_in_out!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{T, T}}} where {T, P}"><code>ZXCalculus.ZXW.import_non_in_out!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add non input and output spiders of d2 to d1, modify d1. Record the mapping of vertex indices.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T, T, ZXCalculus.ZXW.ZXWSpiderType}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZXW.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T, T, ZXCalculus.ZXW.ZXWSpiderType}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZXW.insert_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert_spider!(zxwd, v1, v2, spider)</code></pre><p>Insert a spider <code>spider</code> with appropriate parameter, between two vertices <code>v1</code> and <code>v2</code>. It will insert multiple times if the edge between <code>v1</code> and <code>v2</code> is a multiple edge. Also it will remove the original edge between <code>v1</code> and <code>v2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.insert_wtrig!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vector{T}}} where {T, P}" href="#ZXCalculus.ZXW.insert_wtrig!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vector{T}}} where {T, P}"><code>ZXCalculus.ZXW.insert_wtrig!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Insert W triangle on a vector of vertices</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.int_prep!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T, P}" href="#ZXCalculus.ZXW.int_prep!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T, P}"><code>ZXCalculus.ZXW.int_prep!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Prepare spider at loc for integration.</p><p>Perform the simplified step of zeroing out phase of spider and readying it for integration</p><ol><li>If target spider is X spider, turn it to Z by adding H to all its legs</li><li>Pull out the Phase of the spider</li><li>zero out the phase</li><li>change the current spider back to its original type if necessary,</li></ol><p>will generate one extra H spider.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.integrate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vararg{T, 4}}} where {T, P}" href="#ZXCalculus.ZXW.integrate!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Vararg{T, 4}}} where {T, P}"><code>ZXCalculus.ZXW.integrate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Integrate two pairs of +/- parameter. Theorem 23 of https://arxiv.org/abs/2201.13250</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.nout-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZXW.nout-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZXW.nout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nout(zxwd)</code></pre><p>Returns the number of outputs of a ZXW-diagram</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.nqubits-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZXW.nqubits-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZXW.nqubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nqubits(zxwd)</code></pre><p>Returns the qubit number of a ZXW-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.parameter-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZXW.parameter-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZXW.parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter(zxwd, v)</code></pre><p>Returns the parameter of a spider. If the spider is not a Z or X spider, then return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.print_spider-Union{Tuple{P}, Tuple{T}, Tuple{IO, ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZXW.print_spider-Union{Tuple{P}, Tuple{T}, Tuple{IO, ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZXW.print_spider</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_spider(io, zxwd, v)</code></pre><p>Print a spider to <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.round_phases!-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZXW.round_phases!-Union{Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZXW.round_phases!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_phases!(zxwd)</code></pre><p>Round phases between [0, 2π).</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T, ZXCalculus.Utils.Parameter}} where {T, P}" href="#ZXCalculus.ZXW.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T, ZXCalculus.Utils.Parameter}} where {T, P}"><code>ZXCalculus.ZXW.set_phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_phase!(zxwd, v, p)</code></pre><p>Set the phase of <code>v</code> in <code>zxwd</code> to <code>p</code>. If <code>v</code> is not a Z or X spider, then do nothing. If <code>v</code> is not in <code>zxwd</code>, then return false to indicate failure.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZXW.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZXW.spider_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spider_type(zxwd, v)</code></pre><p>Returns the spider type of a spider if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.stack_zxwd!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}" href="#ZXCalculus.ZXW.stack_zxwd!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, ZXCalculus.ZXW.ZXWDiagram{T, P}}} where {T, P}"><code>ZXCalculus.ZXW.stack_zxwd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Stacking two ZXWDiagrams in place. Modify d1.</p><p>Performs tensor product of two ZXWDiagrams. The result is a ZXWDiagram with d1 on lower qubit indices. Assuming number of inputs and outputs of are the same for both d1 and d2.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.substitute_variables!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{Symbol, &lt;:Number}}} where {T, P}" href="#ZXCalculus.ZXW.substitute_variables!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Dict{Symbol, &lt;:Number}}} where {T, P}"><code>ZXCalculus.ZXW.substitute_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols in ZXW Diagram with specific values</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZXW.symbol_vertices-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Symbol}} where {T, P}" href="#ZXCalculus.ZXW.symbol_vertices-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZXW.ZXWDiagram{T, P}, Symbol}} where {T, P}"><code>ZXCalculus.ZXW.symbol_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Finds vertices of Spider that contains the parameter θ or -θ</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Tuple{ZXCalculus.ZW.ZWDiagram, Any, Int64}" href="#Graphs.SimpleGraphs.add_edge!-Tuple{ZXCalculus.ZW.ZWDiagram, Any, Int64}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Graphs.add_edge!(zwd::ZWDiagram, he, mul)</code></pre><p>Add <code>mul</code> of edges that connects vertices with already connected with edge<code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Tuple{ZXCalculus.ZW.ZWDiagram, Any}" href="#Graphs.SimpleGraphs.rem_edge!-Tuple{ZXCalculus.ZW.ZWDiagram, Any}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(zwd::ZWDiagram, x)</code></pre><p>Remove Edge with indices <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.ne-Tuple{ZXCalculus.ZW.ZWDiagram}" href="#Graphs.ne-Tuple{ZXCalculus.ZW.ZWDiagram}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(zwd)</code></pre><p>Returns the number of edges of a ZW-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.neighbors-Tuple{ZXCalculus.ZW.ZWDiagram, Any}" href="#Graphs.neighbors-Tuple{ZXCalculus.ZW.ZWDiagram, Any}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(zwd, v)</code></pre><p>Returns a vector of vertices connected to <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.nv-Tuple{ZXCalculus.ZW.ZWDiagram}" href="#Graphs.nv-Tuple{ZXCalculus.ZW.ZWDiagram}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(zwd)</code></pre><p>Returns the number of vertices (spiders) of a ZW-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, ZXCalculus.ZW.ZWSpiderType, Vector{T}}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.add_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, ZXCalculus.ZW.ZWSpiderType, Vector{T}}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.add_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_spider!(zwd, spider, connect = [])</code></pre><p>Add a new spider <code>spider</code> with appropriate parameter connected to the half edges <code>connect</code>.</p><p>Had to make halfedge class 1 citizen because there will be ambiguity Consider A to B and there are multiple edges to A and from A to B</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.get_input_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T, P}" href="#ZXCalculus.ZW.get_input_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T, P}"><code>ZXCalculus.ZW.get_input_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_input_idx(zwd::ZXWDiagram{T,P}, q::T) where {T,P}</code></pre><p>Get spider index of input qubit q.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.get_inputs-Tuple{ZXCalculus.ZW.ZWDiagram}" href="#ZXCalculus.ZW.get_inputs-Tuple{ZXCalculus.ZW.ZWDiagram}"><code>ZXCalculus.ZW.get_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_inputs(zwd)</code></pre><p>Returns a vector of input ids.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.get_output_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T, P}" href="#ZXCalculus.ZW.get_output_idx-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T, P}"><code>ZXCalculus.ZW.get_output_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_output_idx(zwd::ZWDiagram{T,P}, q::T) where {T,P}</code></pre><p>Get spider index of output qubit q.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.get_outputs-Tuple{ZXCalculus.ZW.ZWDiagram}" href="#ZXCalculus.ZW.get_outputs-Tuple{ZXCalculus.ZW.ZWDiagram}"><code>ZXCalculus.ZW.get_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_outputs(zwd)</code></pre><p>Returns a vector of output ids.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T, ZXCalculus.ZW.ZWSpiderType}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.insert_spider!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T, ZXCalculus.ZW.ZWSpiderType}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.insert_spider!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert_spider!(zwd, he1, spider)</code></pre><p>Insert a spider <code>spider</code> with appropriate parameter on the half-edge prior to <code>he1</code>. v1 &lt;- he1 - v2 becomes v1 &lt;- he1 - v2 &lt;- he<em>new - v</em>new</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.nout-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZW.nout-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZW.nout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nout(zwd)</code></pre><p>Returns the number of outputs of a ZW-diagram</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.nqubits-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}" href="#ZXCalculus.ZW.nqubits-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T, P}"><code>ZXCalculus.ZW.nqubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nqubits(zwd)</code></pre><p>Returns the qubit number of a ZW-diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.parameter-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.parameter-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter(zwd, v)</code></pre><p>Returns the parameter of a spider. If the spider is not a monoZ or binZ spider, then return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.print_spider-Union{Tuple{P}, Tuple{T}, Tuple{IO, ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.print_spider-Union{Tuple{P}, Tuple{T}, Tuple{IO, ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.print_spider</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_spider(io, zwd, v)</code></pre><p>Print a spider to <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.round_phases!-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.round_phases!-Union{Tuple{ZXCalculus.ZW.ZWDiagram{T, P}}, Tuple{P}, Tuple{T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.round_phases!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_phases!(zwd)</code></pre><p>Round phases between [0, 2π).</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T, ZXCalculus.Utils.Parameter}} where {T, P}" href="#ZXCalculus.ZW.set_phase!-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T, ZXCalculus.Utils.Parameter}} where {T, P}"><code>ZXCalculus.ZW.set_phase!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_phase!(zwd, v, p)</code></pre><p>Set the phase of <code>v</code> in <code>zwd</code> to <code>p</code>. If <code>v</code> is not a monoZ or binZ spider, then do nothing. If <code>v</code> is not in <code>zwd</code>, then return false to indicate failure.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.spider_type-Union{Tuple{P}, Tuple{T}, Tuple{ZXCalculus.ZW.ZWDiagram{T, P}, T}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.spider_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spider_type(zwd, v)</code></pre><p>Returns the spider type of a spider if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZX.spiders-Tuple{ZXCalculus.ZW.ZWDiagram}" href="#ZXCalculus.ZX.spiders-Tuple{ZXCalculus.ZW.ZWDiagram}"><code>ZXCalculus.ZX.spiders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spiders(zwd::ZWDiagram)</code></pre><p>Returns a vector of spider idxs.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.ZW.ZWDiagram-Union{Tuple{P}, Tuple{T}, Tuple{T, Type{P}}} where {T&lt;:Integer, P}" href="#ZXCalculus.ZW.ZWDiagram-Union{Tuple{P}, Tuple{T}, Tuple{T, Type{P}}} where {T&lt;:Integer, P}"><code>ZXCalculus.ZW.ZWDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZWDiagram(nbits::T, ::Type{P}) where {T&lt;:Integer}</code></pre><p>Create a ZW-diagram with <code>nbits</code> input and output qubits.</p><p>Scalar is parameterized to be <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.Utils.Parameter" href="#ZXCalculus.Utils.Parameter"><code>ZXCalculus.Utils.Parameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Parameter</code></pre><p>The Algebraic Data Type for representing parameter related to spider. <code>PiUnit(x)</code> represents the the phase of a number <code>exp(im*x*π)</code>. <code>Factor(x)</code> represents a number <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.Utils.Parameter-Union{Tuple{Val{:PiUnit}}, Tuple{T}, Tuple{Val{:PiUnit}, T}} where T" href="#ZXCalculus.Utils.Parameter-Union{Tuple{Val{:PiUnit}}, Tuple{T}, Tuple{Val{:PiUnit}, T}} where T"><code>ZXCalculus.Utils.Parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parameter Constructors for <code>Parameter</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.Utils.Phase" href="#ZXCalculus.Utils.Phase"><code>ZXCalculus.Utils.Phase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Phase</code></pre><p>The type supports manipulating phases as expressions. <code>Phase(x)</code> represents the number <code>x⋅π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.Utils.Scalar" href="#ZXCalculus.Utils.Scalar"><code>ZXCalculus.Utils.Scalar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Scalar</code></pre><p>A struct for recording the scalars when we rewrite ZX-diagrams.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.add_facet_to_boarder!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.add_facet_to_boarder!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.add_facet_to_boarder!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_facet_to_boarder!(pmg::PlanarMultigraph{T}, h::T, g::T) where {T&lt;:Integer}</code></pre><p>Creates a facet with edge connecting the destination of h and g.</p><p>h and g needs to be in ccw order</p><p><strong>Reference</strong></p><ul><li><a href="https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html#a73119c0c90bf8612da003305af25a52a">CGAL</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.add_vertex_and_facet_to_boarder!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.add_vertex_and_facet_to_boarder!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.add_vertex_and_facet_to_boarder!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_vertex_and_facet_to_boarder!(
pmg::PlanarMultigraph{T},
h::T,
g::T,</code></pre><p>) where {T&lt;:Integer}</p><p>TBW</p><p><strong>Reference</strong></p><ul><li><a href="https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html#a684bc8315f9e97d59e10bf896f0a166c">CGAl</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.create_edge!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.create_edge!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.create_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_edge!(pmg::PlanarMultigraph{T}, vs::T, vd::T) where {T&lt;:Integer}</code></pre><p>Create an a pair of halfedge from vs to vd, add to PlanarMultigraph pmg. Facet information is not updated yet but set to default value of 0. Vertex to halfedge is updated and set to the two newly added half edges.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.create_face!-Union{Tuple{ZXCalculus.PMG.PlanarMultigraph{T}}, Tuple{T}} where T&lt;:Integer" href="#ZXCalculus.PMG.create_face!-Union{Tuple{ZXCalculus.PMG.PlanarMultigraph{T}}, Tuple{T}} where T&lt;:Integer"><code>ZXCalculus.PMG.create_face!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_face!(pmg::PlanarMultigraph{T}) where {T&lt;:Integer}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.create_vertex!-Union{Tuple{ZXCalculus.PMG.PlanarMultigraph{T}}, Tuple{T}} where T&lt;:Integer" href="#ZXCalculus.PMG.create_vertex!-Union{Tuple{ZXCalculus.PMG.PlanarMultigraph{T}}, Tuple{T}} where T&lt;:Integer"><code>ZXCalculus.PMG.create_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_vertex!(g::PlanarMultigraph{T}; mul::Int = 1) where {T&lt;:Integer}</code></pre><p>Create vertices.</p><p>Create <code>mul</code> of vertices and record them in PlanarMultigraph g&#39;s <code>v_max</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.erase_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.erase_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.erase_facet!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erase_facet!(pmg::PlanarMultigraph{T}, h::T)</code></pre><p>Erase the facet incident on h.</p><p><strong>Reference</strong></p><ul><li><a href="https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html#ac67041483c1e7c67c8dfd87716feebea">CGAL Library</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.gc_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, Vector{T}}} where T&lt;:Integer" href="#ZXCalculus.PMG.gc_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, Vector{T}}} where T&lt;:Integer"><code>ZXCalculus.PMG.gc_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gc_vertex!(pmg::PlanarMultigraph{T}, vs::Vector{T}) where {T&lt;:Integer}</code></pre><p>Garbage collect vertices that&#39;s no longer connected to any edge.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.is_boundary-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.is_boundary-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.is_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary(g::PlanarMultigraph{T}, he_id::T) where {T}</code></pre><p>If the half edge is on the boundary of entire manifold</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.join_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.join_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.join_facet!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">join_facet!(pmg::PlanarMultigraph{T}, h::T) where {T}</code></pre><p>Join two facets incident to h and it&#39;s twin into one.</p><p>The facet incident to h&#39;s twin is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.join_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.join_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.join_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">join_vertex!(pmg::PlanarMultigraph{T}, h::T) where {T&lt;:Integer}</code></pre><p>Join two vertices connected by a HalfEdge into one.</p><p>Provides the removal of an edge.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.make_hole!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.make_hole!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.make_hole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_hole!(pmg::PlanarMultigraph{T}, h::T) where {T&lt;:Integer}</code></pre><p>Convert the facet incident to a half edge into a hole.</p><p>Makes all the half edges in the facet a boundary halfedge.</p><p><strong>Reference</strong></p><ul><li><a href="https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html#a228add3cae2d328bcdd67192a98fb636">CGAL</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.n_conn_comp-Tuple{ZXCalculus.PMG.PlanarMultigraph}" href="#ZXCalculus.PMG.n_conn_comp-Tuple{ZXCalculus.PMG.PlanarMultigraph}"><code>ZXCalculus.PMG.n_conn_comp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_conn_comp(g::PlanarMultigraph)</code></pre><p>Return the number of connected components.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.new_edge-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.new_edge-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.new_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_edge(src::T, dst::T) where {T&lt;:Integer}</code></pre><p>Create a half edge and its twin</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.out_half_edge-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.out_half_edge-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.out_half_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">out_half_edge(g::PlanarMultigraph{T}, v::T)</code></pre><p>Get the one out half edge of a vertex</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.prev-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.prev-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.prev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prev(g::PlanarMultigraph{T}, he_id::T) where {T&lt;:Integer}</code></pre><p>Provides Previous Half Edge of a facet. HDS is bidi</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.split_edge!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.split_edge!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.split_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_edge!(pmg::PlanarMultigraph{T}, h::T) where {T&lt;:Integer}</code></pre><p>Split an edge into two consecutive ones. 1-&gt;2-&gt;3 becomes 1-&gt;4-&gt;2-&gt;3</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.split_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.split_facet!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.split_facet!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_facet!(pmg::PlanarMultigraph{T}, h::T, g::T) where {T&lt;:Integer}</code></pre><p>Split a facet incident to h and g into two facets.</p><p><strong>Precondition</strong></p><ol><li>h and g are in the same facet</li><li>h and g are not the same half edge</li><li>Cannot be used to split the faces incident to the multiedge.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.split_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer" href="#ZXCalculus.PMG.split_vertex!-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T, T}} where T&lt;:Integer"><code>ZXCalculus.PMG.split_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_vertex!(g::PlanarMultigraph{T}, he1::T, he2::T) where {T&lt;:Integer}</code></pre><p>Split a vertex into 2 vertices.</p><p>Connect the two vertices with a new pair of half edges. he1 and he2 are half edges that marks the start and end of half edges that remain on v1.</p><p>After splitting, h points to the newly added vertex</p><p><strong>Reference</strong></p><ul><li><a href="https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html#a2b17d7bd2045397167b00616f3b4d622">CGAL</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.surrounding_half_edge-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.surrounding_half_edge-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.surrounding_half_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surrounding_half_edge(g::PlanarMultigraph{T}, f::T)</code></pre><p>Get the one surrounding half edge of a face</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.trace_face-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.trace_face-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.trace_face</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trace_face(g::PlanarMultigraph{T}, f::T; safe_trace = false) where {T}</code></pre><p>Return the half edges of a face.</p><p>If <code>safe_trace</code> is true, then the half edges are returned in scrambled order. Otherwise, the returned half edges are in counter clockwise order but is not guaranteed to be consitent with he2f.</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.σ-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.σ-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ(g::PlanarMultigraph{T}, he_id::T) where {T}</code></pre><p>Get prev<em>at</em>source</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.σ_inv-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.σ_inv-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.σ_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ_inv(pmg::PlanarMultigraph{T}, h::T) where {T}</code></pre><p>Get next<em>at</em>source, clockwise</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.ϕ-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T" href="#ZXCalculus.PMG.ϕ-Union{Tuple{T}, Tuple{ZXCalculus.PMG.PlanarMultigraph{T}, T}} where T"><code>ZXCalculus.PMG.ϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ϕ(g::PlanarMultigraph{T}, he_id::T) where {T}</code></pre><p>Get twin half edge id</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.HalfEdge" href="#ZXCalculus.PMG.HalfEdge"><code>ZXCalculus.PMG.HalfEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HalfEdge{T&lt;:Integer}(src ,dst)</code></pre><p>Datatype to represent a Half Edge</p><p><strong>Reference</strong></p><ul><li>Brönnimann, Hervé [Designing and Implementing a General Purpose Halfedge Data Structure]</li></ul><p>(https://doi.org/10.1007/3-540-44688-5_5)</p><ul><li><a href="https://doc.cgal.org/latest/Arrangement_on_surface_2/classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html">CGAL Library HalfEdge Data Structure</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZXCalculus.PMG.PlanarMultigraph" href="#ZXCalculus.PMG.PlanarMultigraph"><code>ZXCalculus.PMG.PlanarMultigraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlanarMultigraph{T&lt;:Integer}</code></pre><p>Implements a planar multigraph with a maximal HDS Structure.</p><p><strong>Features</strong></p><ol><li>Stores Forward Half Edge pointer in facet</li><li>Vertex linked</li><li>Face Linked</li></ol><p><strong>References:</strong></p><p>Our implementation is based heavily on the <a href="https://www.cgal.org/">CGAL Library</a>. A good introduction on the HDS Structure and the Polyhedron3 Object which gives the boundary representation of a 2-manifold can be found in this <a href="https://linkinghub.elsevier.com/retrieve/pii/S0925772199000073">paper</a>.</p><p><strong>TODO: Proof of Completeness for Euler Operations with Preconditions In the</strong></p><p>CGAL Library, the Euler Operations are implemented with preconditions. It was pointed out that Euler Operations are closed for orientable 2-manifolds in <a href="https://www.sciencedirect.com/science/article/pii/S0925772199000073?via%3Dihub">paper</a> where the detailed proof is in <a href="https://books.google.co.jp/books?id=CJVRAAAAMAAJ">book</a>. It was further pointed out in <a href="https://www.sciencedirect.com/science/article/abs/pii/0734189X84901294">paper</a> that Euler Operations are complete in Theorem 4.4.</p><p>The question remains whether the completeness remains for the preconditions attached. One way of proving is to show that for the Euler Operations used in Theorem 4.4, we could always construct them out of the Euler Operations in CGAL Library with preconditions?</p></div><a class="docs-sourcelink" target="_blank" href="https:/github.com/QuantumBFS/ZXCalculus.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 23 October 2023 18:30">Monday 23 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
